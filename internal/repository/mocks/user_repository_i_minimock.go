// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/sSmok/auth/internal/repository.UserRepositoryI -o user_repository_i_minimock.go -n UserRepositoryIMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/sSmok/auth/internal/model"
)

// UserRepositoryIMock implements mm_repository.UserRepositoryI
type UserRepositoryIMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateUser          func(ctx context.Context, info *model.UserInfo, password string) (i1 int64, err error)
	funcCreateUserOrigin    string
	inspectFuncCreateUser   func(ctx context.Context, info *model.UserInfo, password string)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mUserRepositoryIMockCreateUser

	funcDeleteUser          func(ctx context.Context, id int64) (err error)
	funcDeleteUserOrigin    string
	inspectFuncDeleteUser   func(ctx context.Context, id int64)
	afterDeleteUserCounter  uint64
	beforeDeleteUserCounter uint64
	DeleteUserMock          mUserRepositoryIMockDeleteUser

	funcGetUser          func(ctx context.Context, id int64) (up1 *model.User, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, id int64)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mUserRepositoryIMockGetUser

	funcGetUserByEmail          func(ctx context.Context, email string) (up1 *model.User, err error)
	funcGetUserByEmailOrigin    string
	inspectFuncGetUserByEmail   func(ctx context.Context, email string)
	afterGetUserByEmailCounter  uint64
	beforeGetUserByEmailCounter uint64
	GetUserByEmailMock          mUserRepositoryIMockGetUserByEmail

	funcUpdateUser          func(ctx context.Context, id int64, info *model.UserInfo) (err error)
	funcUpdateUserOrigin    string
	inspectFuncUpdateUser   func(ctx context.Context, id int64, info *model.UserInfo)
	afterUpdateUserCounter  uint64
	beforeUpdateUserCounter uint64
	UpdateUserMock          mUserRepositoryIMockUpdateUser
}

// NewUserRepositoryIMock returns a mock for mm_repository.UserRepositoryI
func NewUserRepositoryIMock(t minimock.Tester) *UserRepositoryIMock {
	m := &UserRepositoryIMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateUserMock = mUserRepositoryIMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*UserRepositoryIMockCreateUserParams{}

	m.DeleteUserMock = mUserRepositoryIMockDeleteUser{mock: m}
	m.DeleteUserMock.callArgs = []*UserRepositoryIMockDeleteUserParams{}

	m.GetUserMock = mUserRepositoryIMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*UserRepositoryIMockGetUserParams{}

	m.GetUserByEmailMock = mUserRepositoryIMockGetUserByEmail{mock: m}
	m.GetUserByEmailMock.callArgs = []*UserRepositoryIMockGetUserByEmailParams{}

	m.UpdateUserMock = mUserRepositoryIMockUpdateUser{mock: m}
	m.UpdateUserMock.callArgs = []*UserRepositoryIMockUpdateUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mUserRepositoryIMockCreateUser struct {
	optional           bool
	mock               *UserRepositoryIMock
	defaultExpectation *UserRepositoryIMockCreateUserExpectation
	expectations       []*UserRepositoryIMockCreateUserExpectation

	callArgs []*UserRepositoryIMockCreateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryIMockCreateUserExpectation specifies expectation struct of the UserRepositoryI.CreateUser
type UserRepositoryIMockCreateUserExpectation struct {
	mock               *UserRepositoryIMock
	params             *UserRepositoryIMockCreateUserParams
	paramPtrs          *UserRepositoryIMockCreateUserParamPtrs
	expectationOrigins UserRepositoryIMockCreateUserExpectationOrigins
	results            *UserRepositoryIMockCreateUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryIMockCreateUserParams contains parameters of the UserRepositoryI.CreateUser
type UserRepositoryIMockCreateUserParams struct {
	ctx      context.Context
	info     *model.UserInfo
	password string
}

// UserRepositoryIMockCreateUserParamPtrs contains pointers to parameters of the UserRepositoryI.CreateUser
type UserRepositoryIMockCreateUserParamPtrs struct {
	ctx      *context.Context
	info     **model.UserInfo
	password *string
}

// UserRepositoryIMockCreateUserResults contains results of the UserRepositoryI.CreateUser
type UserRepositoryIMockCreateUserResults struct {
	i1  int64
	err error
}

// UserRepositoryIMockCreateUserOrigins contains origins of expectations of the UserRepositoryI.CreateUser
type UserRepositoryIMockCreateUserExpectationOrigins struct {
	origin         string
	originCtx      string
	originInfo     string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateUser *mUserRepositoryIMockCreateUser) Optional() *mUserRepositoryIMockCreateUser {
	mmCreateUser.optional = true
	return mmCreateUser
}

// Expect sets up expected params for UserRepositoryI.CreateUser
func (mmCreateUser *mUserRepositoryIMockCreateUser) Expect(ctx context.Context, info *model.UserInfo, password string) *mUserRepositoryIMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryIMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryIMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.paramPtrs != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryIMock.CreateUser mock is already set by ExpectParams functions")
	}

	mmCreateUser.defaultExpectation.params = &UserRepositoryIMockCreateUserParams{ctx, info, password}
	mmCreateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRepositoryI.CreateUser
func (mmCreateUser *mUserRepositoryIMockCreateUser) ExpectCtxParam1(ctx context.Context) *mUserRepositoryIMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryIMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryIMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryIMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserRepositoryIMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectInfoParam2 sets up expected param info for UserRepositoryI.CreateUser
func (mmCreateUser *mUserRepositoryIMockCreateUser) ExpectInfoParam2(info *model.UserInfo) *mUserRepositoryIMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryIMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryIMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryIMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserRepositoryIMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.info = &info
	mmCreateUser.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmCreateUser
}

// ExpectPasswordParam3 sets up expected param password for UserRepositoryI.CreateUser
func (mmCreateUser *mUserRepositoryIMockCreateUser) ExpectPasswordParam3(password string) *mUserRepositoryIMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryIMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryIMockCreateUserExpectation{}
	}

	if mmCreateUser.defaultExpectation.params != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryIMock.CreateUser mock is already set by Expect")
	}

	if mmCreateUser.defaultExpectation.paramPtrs == nil {
		mmCreateUser.defaultExpectation.paramPtrs = &UserRepositoryIMockCreateUserParamPtrs{}
	}
	mmCreateUser.defaultExpectation.paramPtrs.password = &password
	mmCreateUser.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the UserRepositoryI.CreateUser
func (mmCreateUser *mUserRepositoryIMockCreateUser) Inspect(f func(ctx context.Context, info *model.UserInfo, password string)) *mUserRepositoryIMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for UserRepositoryIMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by UserRepositoryI.CreateUser
func (mmCreateUser *mUserRepositoryIMockCreateUser) Return(i1 int64, err error) *UserRepositoryIMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryIMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &UserRepositoryIMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &UserRepositoryIMockCreateUserResults{i1, err}
	mmCreateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// Set uses given function f to mock the UserRepositoryI.CreateUser method
func (mmCreateUser *mUserRepositoryIMockCreateUser) Set(f func(ctx context.Context, info *model.UserInfo, password string) (i1 int64, err error)) *UserRepositoryIMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the UserRepositoryI.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the UserRepositoryI.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	mmCreateUser.mock.funcCreateUserOrigin = minimock.CallerInfo(1)
	return mmCreateUser.mock
}

// When sets expectation for the UserRepositoryI.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mUserRepositoryIMockCreateUser) When(ctx context.Context, info *model.UserInfo, password string) *UserRepositoryIMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("UserRepositoryIMock.CreateUser mock is already set by Set")
	}

	expectation := &UserRepositoryIMockCreateUserExpectation{
		mock:               mmCreateUser.mock,
		params:             &UserRepositoryIMockCreateUserParams{ctx, info, password},
		expectationOrigins: UserRepositoryIMockCreateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up UserRepositoryI.CreateUser return parameters for the expectation previously defined by the When method
func (e *UserRepositoryIMockCreateUserExpectation) Then(i1 int64, err error) *UserRepositoryIMock {
	e.results = &UserRepositoryIMockCreateUserResults{i1, err}
	return e.mock
}

// Times sets number of times UserRepositoryI.CreateUser should be invoked
func (mmCreateUser *mUserRepositoryIMockCreateUser) Times(n uint64) *mUserRepositoryIMockCreateUser {
	if n == 0 {
		mmCreateUser.mock.t.Fatalf("Times of UserRepositoryIMock.CreateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateUser.expectedInvocations, n)
	mmCreateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateUser
}

func (mmCreateUser *mUserRepositoryIMockCreateUser) invocationsDone() bool {
	if len(mmCreateUser.expectations) == 0 && mmCreateUser.defaultExpectation == nil && mmCreateUser.mock.funcCreateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateUser.mock.afterCreateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateUser implements mm_repository.UserRepositoryI
func (mmCreateUser *UserRepositoryIMock) CreateUser(ctx context.Context, info *model.UserInfo, password string) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	mmCreateUser.t.Helper()

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, info, password)
	}

	mm_params := UserRepositoryIMockCreateUserParams{ctx, info, password}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, &mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_want_ptrs := mmCreateUser.CreateUserMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryIMockCreateUserParams{ctx, info, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateUser.t.Errorf("UserRepositoryIMock.CreateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmCreateUser.t.Errorf("UserRepositoryIMock.CreateUser got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmCreateUser.t.Errorf("UserRepositoryIMock.CreateUser got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("UserRepositoryIMock.CreateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateUser.CreateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the UserRepositoryIMock.CreateUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, info, password)
	}
	mmCreateUser.t.Fatalf("Unexpected call to UserRepositoryIMock.CreateUser. %v %v %v", ctx, info, password)
	return
}

// CreateUserAfterCounter returns a count of finished UserRepositoryIMock.CreateUser invocations
func (mmCreateUser *UserRepositoryIMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of UserRepositoryIMock.CreateUser invocations
func (mmCreateUser *UserRepositoryIMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryIMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mUserRepositoryIMockCreateUser) Calls() []*UserRepositoryIMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*UserRepositoryIMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *UserRepositoryIMock) MinimockCreateUserDone() bool {
	if m.CreateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateUserMock.invocationsDone()
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *UserRepositoryIMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryIMock.CreateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateUserCounter := mm_atomic.LoadUint64(&m.afterCreateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && afterCreateUserCounter < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryIMock.CreateUser at\n%s", m.CreateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryIMock.CreateUser at\n%s with params: %#v", m.CreateUserMock.defaultExpectation.expectationOrigins.origin, *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && afterCreateUserCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryIMock.CreateUser at\n%s", m.funcCreateUserOrigin)
	}

	if !m.CreateUserMock.invocationsDone() && afterCreateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryIMock.CreateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateUserMock.expectedInvocations), m.CreateUserMock.expectedInvocationsOrigin, afterCreateUserCounter)
	}
}

type mUserRepositoryIMockDeleteUser struct {
	optional           bool
	mock               *UserRepositoryIMock
	defaultExpectation *UserRepositoryIMockDeleteUserExpectation
	expectations       []*UserRepositoryIMockDeleteUserExpectation

	callArgs []*UserRepositoryIMockDeleteUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryIMockDeleteUserExpectation specifies expectation struct of the UserRepositoryI.DeleteUser
type UserRepositoryIMockDeleteUserExpectation struct {
	mock               *UserRepositoryIMock
	params             *UserRepositoryIMockDeleteUserParams
	paramPtrs          *UserRepositoryIMockDeleteUserParamPtrs
	expectationOrigins UserRepositoryIMockDeleteUserExpectationOrigins
	results            *UserRepositoryIMockDeleteUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryIMockDeleteUserParams contains parameters of the UserRepositoryI.DeleteUser
type UserRepositoryIMockDeleteUserParams struct {
	ctx context.Context
	id  int64
}

// UserRepositoryIMockDeleteUserParamPtrs contains pointers to parameters of the UserRepositoryI.DeleteUser
type UserRepositoryIMockDeleteUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserRepositoryIMockDeleteUserResults contains results of the UserRepositoryI.DeleteUser
type UserRepositoryIMockDeleteUserResults struct {
	err error
}

// UserRepositoryIMockDeleteUserOrigins contains origins of expectations of the UserRepositoryI.DeleteUser
type UserRepositoryIMockDeleteUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteUser *mUserRepositoryIMockDeleteUser) Optional() *mUserRepositoryIMockDeleteUser {
	mmDeleteUser.optional = true
	return mmDeleteUser
}

// Expect sets up expected params for UserRepositoryI.DeleteUser
func (mmDeleteUser *mUserRepositoryIMockDeleteUser) Expect(ctx context.Context, id int64) *mUserRepositoryIMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryIMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRepositoryIMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.paramPtrs != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryIMock.DeleteUser mock is already set by ExpectParams functions")
	}

	mmDeleteUser.defaultExpectation.params = &UserRepositoryIMockDeleteUserParams{ctx, id}
	mmDeleteUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteUser.expectations {
		if minimock.Equal(e.params, mmDeleteUser.defaultExpectation.params) {
			mmDeleteUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteUser.defaultExpectation.params)
		}
	}

	return mmDeleteUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRepositoryI.DeleteUser
func (mmDeleteUser *mUserRepositoryIMockDeleteUser) ExpectCtxParam1(ctx context.Context) *mUserRepositoryIMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryIMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRepositoryIMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryIMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserRepositoryIMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteUser
}

// ExpectIdParam2 sets up expected param id for UserRepositoryI.DeleteUser
func (mmDeleteUser *mUserRepositoryIMockDeleteUser) ExpectIdParam2(id int64) *mUserRepositoryIMockDeleteUser {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryIMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRepositoryIMockDeleteUserExpectation{}
	}

	if mmDeleteUser.defaultExpectation.params != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryIMock.DeleteUser mock is already set by Expect")
	}

	if mmDeleteUser.defaultExpectation.paramPtrs == nil {
		mmDeleteUser.defaultExpectation.paramPtrs = &UserRepositoryIMockDeleteUserParamPtrs{}
	}
	mmDeleteUser.defaultExpectation.paramPtrs.id = &id
	mmDeleteUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDeleteUser
}

// Inspect accepts an inspector function that has same arguments as the UserRepositoryI.DeleteUser
func (mmDeleteUser *mUserRepositoryIMockDeleteUser) Inspect(f func(ctx context.Context, id int64)) *mUserRepositoryIMockDeleteUser {
	if mmDeleteUser.mock.inspectFuncDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("Inspect function is already set for UserRepositoryIMock.DeleteUser")
	}

	mmDeleteUser.mock.inspectFuncDeleteUser = f

	return mmDeleteUser
}

// Return sets up results that will be returned by UserRepositoryI.DeleteUser
func (mmDeleteUser *mUserRepositoryIMockDeleteUser) Return(err error) *UserRepositoryIMock {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryIMock.DeleteUser mock is already set by Set")
	}

	if mmDeleteUser.defaultExpectation == nil {
		mmDeleteUser.defaultExpectation = &UserRepositoryIMockDeleteUserExpectation{mock: mmDeleteUser.mock}
	}
	mmDeleteUser.defaultExpectation.results = &UserRepositoryIMockDeleteUserResults{err}
	mmDeleteUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// Set uses given function f to mock the UserRepositoryI.DeleteUser method
func (mmDeleteUser *mUserRepositoryIMockDeleteUser) Set(f func(ctx context.Context, id int64) (err error)) *UserRepositoryIMock {
	if mmDeleteUser.defaultExpectation != nil {
		mmDeleteUser.mock.t.Fatalf("Default expectation is already set for the UserRepositoryI.DeleteUser method")
	}

	if len(mmDeleteUser.expectations) > 0 {
		mmDeleteUser.mock.t.Fatalf("Some expectations are already set for the UserRepositoryI.DeleteUser method")
	}

	mmDeleteUser.mock.funcDeleteUser = f
	mmDeleteUser.mock.funcDeleteUserOrigin = minimock.CallerInfo(1)
	return mmDeleteUser.mock
}

// When sets expectation for the UserRepositoryI.DeleteUser which will trigger the result defined by the following
// Then helper
func (mmDeleteUser *mUserRepositoryIMockDeleteUser) When(ctx context.Context, id int64) *UserRepositoryIMockDeleteUserExpectation {
	if mmDeleteUser.mock.funcDeleteUser != nil {
		mmDeleteUser.mock.t.Fatalf("UserRepositoryIMock.DeleteUser mock is already set by Set")
	}

	expectation := &UserRepositoryIMockDeleteUserExpectation{
		mock:               mmDeleteUser.mock,
		params:             &UserRepositoryIMockDeleteUserParams{ctx, id},
		expectationOrigins: UserRepositoryIMockDeleteUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteUser.expectations = append(mmDeleteUser.expectations, expectation)
	return expectation
}

// Then sets up UserRepositoryI.DeleteUser return parameters for the expectation previously defined by the When method
func (e *UserRepositoryIMockDeleteUserExpectation) Then(err error) *UserRepositoryIMock {
	e.results = &UserRepositoryIMockDeleteUserResults{err}
	return e.mock
}

// Times sets number of times UserRepositoryI.DeleteUser should be invoked
func (mmDeleteUser *mUserRepositoryIMockDeleteUser) Times(n uint64) *mUserRepositoryIMockDeleteUser {
	if n == 0 {
		mmDeleteUser.mock.t.Fatalf("Times of UserRepositoryIMock.DeleteUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteUser.expectedInvocations, n)
	mmDeleteUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteUser
}

func (mmDeleteUser *mUserRepositoryIMockDeleteUser) invocationsDone() bool {
	if len(mmDeleteUser.expectations) == 0 && mmDeleteUser.defaultExpectation == nil && mmDeleteUser.mock.funcDeleteUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteUser.mock.afterDeleteUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteUser implements mm_repository.UserRepositoryI
func (mmDeleteUser *UserRepositoryIMock) DeleteUser(ctx context.Context, id int64) (err error) {
	mm_atomic.AddUint64(&mmDeleteUser.beforeDeleteUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteUser.afterDeleteUserCounter, 1)

	mmDeleteUser.t.Helper()

	if mmDeleteUser.inspectFuncDeleteUser != nil {
		mmDeleteUser.inspectFuncDeleteUser(ctx, id)
	}

	mm_params := UserRepositoryIMockDeleteUserParams{ctx, id}

	// Record call args
	mmDeleteUser.DeleteUserMock.mutex.Lock()
	mmDeleteUser.DeleteUserMock.callArgs = append(mmDeleteUser.DeleteUserMock.callArgs, &mm_params)
	mmDeleteUser.DeleteUserMock.mutex.Unlock()

	for _, e := range mmDeleteUser.DeleteUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteUser.DeleteUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteUser.DeleteUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteUser.DeleteUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteUser.DeleteUserMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryIMockDeleteUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteUser.t.Errorf("UserRepositoryIMock.DeleteUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDeleteUser.t.Errorf("UserRepositoryIMock.DeleteUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteUser.t.Errorf("UserRepositoryIMock.DeleteUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteUser.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteUser.DeleteUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteUser.t.Fatal("No results are set for the UserRepositoryIMock.DeleteUser")
		}
		return (*mm_results).err
	}
	if mmDeleteUser.funcDeleteUser != nil {
		return mmDeleteUser.funcDeleteUser(ctx, id)
	}
	mmDeleteUser.t.Fatalf("Unexpected call to UserRepositoryIMock.DeleteUser. %v %v", ctx, id)
	return
}

// DeleteUserAfterCounter returns a count of finished UserRepositoryIMock.DeleteUser invocations
func (mmDeleteUser *UserRepositoryIMock) DeleteUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.afterDeleteUserCounter)
}

// DeleteUserBeforeCounter returns a count of UserRepositoryIMock.DeleteUser invocations
func (mmDeleteUser *UserRepositoryIMock) DeleteUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteUser.beforeDeleteUserCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryIMock.DeleteUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteUser *mUserRepositoryIMockDeleteUser) Calls() []*UserRepositoryIMockDeleteUserParams {
	mmDeleteUser.mutex.RLock()

	argCopy := make([]*UserRepositoryIMockDeleteUserParams, len(mmDeleteUser.callArgs))
	copy(argCopy, mmDeleteUser.callArgs)

	mmDeleteUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteUserDone returns true if the count of the DeleteUser invocations corresponds
// the number of defined expectations
func (m *UserRepositoryIMock) MinimockDeleteUserDone() bool {
	if m.DeleteUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteUserMock.invocationsDone()
}

// MinimockDeleteUserInspect logs each unmet expectation
func (m *UserRepositoryIMock) MinimockDeleteUserInspect() {
	for _, e := range m.DeleteUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryIMock.DeleteUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteUserCounter := mm_atomic.LoadUint64(&m.afterDeleteUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteUserMock.defaultExpectation != nil && afterDeleteUserCounter < 1 {
		if m.DeleteUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryIMock.DeleteUser at\n%s", m.DeleteUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryIMock.DeleteUser at\n%s with params: %#v", m.DeleteUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteUser != nil && afterDeleteUserCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryIMock.DeleteUser at\n%s", m.funcDeleteUserOrigin)
	}

	if !m.DeleteUserMock.invocationsDone() && afterDeleteUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryIMock.DeleteUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteUserMock.expectedInvocations), m.DeleteUserMock.expectedInvocationsOrigin, afterDeleteUserCounter)
	}
}

type mUserRepositoryIMockGetUser struct {
	optional           bool
	mock               *UserRepositoryIMock
	defaultExpectation *UserRepositoryIMockGetUserExpectation
	expectations       []*UserRepositoryIMockGetUserExpectation

	callArgs []*UserRepositoryIMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryIMockGetUserExpectation specifies expectation struct of the UserRepositoryI.GetUser
type UserRepositoryIMockGetUserExpectation struct {
	mock               *UserRepositoryIMock
	params             *UserRepositoryIMockGetUserParams
	paramPtrs          *UserRepositoryIMockGetUserParamPtrs
	expectationOrigins UserRepositoryIMockGetUserExpectationOrigins
	results            *UserRepositoryIMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryIMockGetUserParams contains parameters of the UserRepositoryI.GetUser
type UserRepositoryIMockGetUserParams struct {
	ctx context.Context
	id  int64
}

// UserRepositoryIMockGetUserParamPtrs contains pointers to parameters of the UserRepositoryI.GetUser
type UserRepositoryIMockGetUserParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// UserRepositoryIMockGetUserResults contains results of the UserRepositoryI.GetUser
type UserRepositoryIMockGetUserResults struct {
	up1 *model.User
	err error
}

// UserRepositoryIMockGetUserOrigins contains origins of expectations of the UserRepositoryI.GetUser
type UserRepositoryIMockGetUserExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mUserRepositoryIMockGetUser) Optional() *mUserRepositoryIMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for UserRepositoryI.GetUser
func (mmGetUser *mUserRepositoryIMockGetUser) Expect(ctx context.Context, id int64) *mUserRepositoryIMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryIMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserRepositoryIMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryIMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &UserRepositoryIMockGetUserParams{ctx, id}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRepositoryI.GetUser
func (mmGetUser *mUserRepositoryIMockGetUser) ExpectCtxParam1(ctx context.Context) *mUserRepositoryIMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryIMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserRepositoryIMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryIMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserRepositoryIMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectIdParam2 sets up expected param id for UserRepositoryI.GetUser
func (mmGetUser *mUserRepositoryIMockGetUser) ExpectIdParam2(id int64) *mUserRepositoryIMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryIMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserRepositoryIMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryIMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &UserRepositoryIMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.id = &id
	mmGetUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the UserRepositoryI.GetUser
func (mmGetUser *mUserRepositoryIMockGetUser) Inspect(f func(ctx context.Context, id int64)) *mUserRepositoryIMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for UserRepositoryIMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by UserRepositoryI.GetUser
func (mmGetUser *mUserRepositoryIMockGetUser) Return(up1 *model.User, err error) *UserRepositoryIMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryIMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &UserRepositoryIMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &UserRepositoryIMockGetUserResults{up1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the UserRepositoryI.GetUser method
func (mmGetUser *mUserRepositoryIMockGetUser) Set(f func(ctx context.Context, id int64) (up1 *model.User, err error)) *UserRepositoryIMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the UserRepositoryI.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the UserRepositoryI.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the UserRepositoryI.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mUserRepositoryIMockGetUser) When(ctx context.Context, id int64) *UserRepositoryIMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("UserRepositoryIMock.GetUser mock is already set by Set")
	}

	expectation := &UserRepositoryIMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &UserRepositoryIMockGetUserParams{ctx, id},
		expectationOrigins: UserRepositoryIMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up UserRepositoryI.GetUser return parameters for the expectation previously defined by the When method
func (e *UserRepositoryIMockGetUserExpectation) Then(up1 *model.User, err error) *UserRepositoryIMock {
	e.results = &UserRepositoryIMockGetUserResults{up1, err}
	return e.mock
}

// Times sets number of times UserRepositoryI.GetUser should be invoked
func (mmGetUser *mUserRepositoryIMockGetUser) Times(n uint64) *mUserRepositoryIMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of UserRepositoryIMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mUserRepositoryIMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_repository.UserRepositoryI
func (mmGetUser *UserRepositoryIMock) GetUser(ctx context.Context, id int64) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, id)
	}

	mm_params := UserRepositoryIMockGetUserParams{ctx, id}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryIMockGetUserParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("UserRepositoryIMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetUser.t.Errorf("UserRepositoryIMock.GetUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("UserRepositoryIMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the UserRepositoryIMock.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, id)
	}
	mmGetUser.t.Fatalf("Unexpected call to UserRepositoryIMock.GetUser. %v %v", ctx, id)
	return
}

// GetUserAfterCounter returns a count of finished UserRepositoryIMock.GetUser invocations
func (mmGetUser *UserRepositoryIMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of UserRepositoryIMock.GetUser invocations
func (mmGetUser *UserRepositoryIMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryIMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mUserRepositoryIMockGetUser) Calls() []*UserRepositoryIMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*UserRepositoryIMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *UserRepositoryIMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *UserRepositoryIMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryIMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryIMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryIMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryIMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryIMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mUserRepositoryIMockGetUserByEmail struct {
	optional           bool
	mock               *UserRepositoryIMock
	defaultExpectation *UserRepositoryIMockGetUserByEmailExpectation
	expectations       []*UserRepositoryIMockGetUserByEmailExpectation

	callArgs []*UserRepositoryIMockGetUserByEmailParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryIMockGetUserByEmailExpectation specifies expectation struct of the UserRepositoryI.GetUserByEmail
type UserRepositoryIMockGetUserByEmailExpectation struct {
	mock               *UserRepositoryIMock
	params             *UserRepositoryIMockGetUserByEmailParams
	paramPtrs          *UserRepositoryIMockGetUserByEmailParamPtrs
	expectationOrigins UserRepositoryIMockGetUserByEmailExpectationOrigins
	results            *UserRepositoryIMockGetUserByEmailResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryIMockGetUserByEmailParams contains parameters of the UserRepositoryI.GetUserByEmail
type UserRepositoryIMockGetUserByEmailParams struct {
	ctx   context.Context
	email string
}

// UserRepositoryIMockGetUserByEmailParamPtrs contains pointers to parameters of the UserRepositoryI.GetUserByEmail
type UserRepositoryIMockGetUserByEmailParamPtrs struct {
	ctx   *context.Context
	email *string
}

// UserRepositoryIMockGetUserByEmailResults contains results of the UserRepositoryI.GetUserByEmail
type UserRepositoryIMockGetUserByEmailResults struct {
	up1 *model.User
	err error
}

// UserRepositoryIMockGetUserByEmailOrigins contains origins of expectations of the UserRepositoryI.GetUserByEmail
type UserRepositoryIMockGetUserByEmailExpectationOrigins struct {
	origin      string
	originCtx   string
	originEmail string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUserByEmail *mUserRepositoryIMockGetUserByEmail) Optional() *mUserRepositoryIMockGetUserByEmail {
	mmGetUserByEmail.optional = true
	return mmGetUserByEmail
}

// Expect sets up expected params for UserRepositoryI.GetUserByEmail
func (mmGetUserByEmail *mUserRepositoryIMockGetUserByEmail) Expect(ctx context.Context, email string) *mUserRepositoryIMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryIMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UserRepositoryIMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryIMock.GetUserByEmail mock is already set by ExpectParams functions")
	}

	mmGetUserByEmail.defaultExpectation.params = &UserRepositoryIMockGetUserByEmailParams{ctx, email}
	mmGetUserByEmail.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUserByEmail.expectations {
		if minimock.Equal(e.params, mmGetUserByEmail.defaultExpectation.params) {
			mmGetUserByEmail.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByEmail.defaultExpectation.params)
		}
	}

	return mmGetUserByEmail
}

// ExpectCtxParam1 sets up expected param ctx for UserRepositoryI.GetUserByEmail
func (mmGetUserByEmail *mUserRepositoryIMockGetUserByEmail) ExpectCtxParam1(ctx context.Context) *mUserRepositoryIMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryIMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UserRepositoryIMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.params != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryIMock.GetUserByEmail mock is already set by Expect")
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs == nil {
		mmGetUserByEmail.defaultExpectation.paramPtrs = &UserRepositoryIMockGetUserByEmailParamPtrs{}
	}
	mmGetUserByEmail.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUserByEmail.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUserByEmail
}

// ExpectEmailParam2 sets up expected param email for UserRepositoryI.GetUserByEmail
func (mmGetUserByEmail *mUserRepositoryIMockGetUserByEmail) ExpectEmailParam2(email string) *mUserRepositoryIMockGetUserByEmail {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryIMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UserRepositoryIMockGetUserByEmailExpectation{}
	}

	if mmGetUserByEmail.defaultExpectation.params != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryIMock.GetUserByEmail mock is already set by Expect")
	}

	if mmGetUserByEmail.defaultExpectation.paramPtrs == nil {
		mmGetUserByEmail.defaultExpectation.paramPtrs = &UserRepositoryIMockGetUserByEmailParamPtrs{}
	}
	mmGetUserByEmail.defaultExpectation.paramPtrs.email = &email
	mmGetUserByEmail.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmGetUserByEmail
}

// Inspect accepts an inspector function that has same arguments as the UserRepositoryI.GetUserByEmail
func (mmGetUserByEmail *mUserRepositoryIMockGetUserByEmail) Inspect(f func(ctx context.Context, email string)) *mUserRepositoryIMockGetUserByEmail {
	if mmGetUserByEmail.mock.inspectFuncGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("Inspect function is already set for UserRepositoryIMock.GetUserByEmail")
	}

	mmGetUserByEmail.mock.inspectFuncGetUserByEmail = f

	return mmGetUserByEmail
}

// Return sets up results that will be returned by UserRepositoryI.GetUserByEmail
func (mmGetUserByEmail *mUserRepositoryIMockGetUserByEmail) Return(up1 *model.User, err error) *UserRepositoryIMock {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryIMock.GetUserByEmail mock is already set by Set")
	}

	if mmGetUserByEmail.defaultExpectation == nil {
		mmGetUserByEmail.defaultExpectation = &UserRepositoryIMockGetUserByEmailExpectation{mock: mmGetUserByEmail.mock}
	}
	mmGetUserByEmail.defaultExpectation.results = &UserRepositoryIMockGetUserByEmailResults{up1, err}
	mmGetUserByEmail.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail.mock
}

// Set uses given function f to mock the UserRepositoryI.GetUserByEmail method
func (mmGetUserByEmail *mUserRepositoryIMockGetUserByEmail) Set(f func(ctx context.Context, email string) (up1 *model.User, err error)) *UserRepositoryIMock {
	if mmGetUserByEmail.defaultExpectation != nil {
		mmGetUserByEmail.mock.t.Fatalf("Default expectation is already set for the UserRepositoryI.GetUserByEmail method")
	}

	if len(mmGetUserByEmail.expectations) > 0 {
		mmGetUserByEmail.mock.t.Fatalf("Some expectations are already set for the UserRepositoryI.GetUserByEmail method")
	}

	mmGetUserByEmail.mock.funcGetUserByEmail = f
	mmGetUserByEmail.mock.funcGetUserByEmailOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail.mock
}

// When sets expectation for the UserRepositoryI.GetUserByEmail which will trigger the result defined by the following
// Then helper
func (mmGetUserByEmail *mUserRepositoryIMockGetUserByEmail) When(ctx context.Context, email string) *UserRepositoryIMockGetUserByEmailExpectation {
	if mmGetUserByEmail.mock.funcGetUserByEmail != nil {
		mmGetUserByEmail.mock.t.Fatalf("UserRepositoryIMock.GetUserByEmail mock is already set by Set")
	}

	expectation := &UserRepositoryIMockGetUserByEmailExpectation{
		mock:               mmGetUserByEmail.mock,
		params:             &UserRepositoryIMockGetUserByEmailParams{ctx, email},
		expectationOrigins: UserRepositoryIMockGetUserByEmailExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUserByEmail.expectations = append(mmGetUserByEmail.expectations, expectation)
	return expectation
}

// Then sets up UserRepositoryI.GetUserByEmail return parameters for the expectation previously defined by the When method
func (e *UserRepositoryIMockGetUserByEmailExpectation) Then(up1 *model.User, err error) *UserRepositoryIMock {
	e.results = &UserRepositoryIMockGetUserByEmailResults{up1, err}
	return e.mock
}

// Times sets number of times UserRepositoryI.GetUserByEmail should be invoked
func (mmGetUserByEmail *mUserRepositoryIMockGetUserByEmail) Times(n uint64) *mUserRepositoryIMockGetUserByEmail {
	if n == 0 {
		mmGetUserByEmail.mock.t.Fatalf("Times of UserRepositoryIMock.GetUserByEmail mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUserByEmail.expectedInvocations, n)
	mmGetUserByEmail.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUserByEmail
}

func (mmGetUserByEmail *mUserRepositoryIMockGetUserByEmail) invocationsDone() bool {
	if len(mmGetUserByEmail.expectations) == 0 && mmGetUserByEmail.defaultExpectation == nil && mmGetUserByEmail.mock.funcGetUserByEmail == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUserByEmail.mock.afterGetUserByEmailCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUserByEmail.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUserByEmail implements mm_repository.UserRepositoryI
func (mmGetUserByEmail *UserRepositoryIMock) GetUserByEmail(ctx context.Context, email string) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByEmail.beforeGetUserByEmailCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByEmail.afterGetUserByEmailCounter, 1)

	mmGetUserByEmail.t.Helper()

	if mmGetUserByEmail.inspectFuncGetUserByEmail != nil {
		mmGetUserByEmail.inspectFuncGetUserByEmail(ctx, email)
	}

	mm_params := UserRepositoryIMockGetUserByEmailParams{ctx, email}

	// Record call args
	mmGetUserByEmail.GetUserByEmailMock.mutex.Lock()
	mmGetUserByEmail.GetUserByEmailMock.callArgs = append(mmGetUserByEmail.GetUserByEmailMock.callArgs, &mm_params)
	mmGetUserByEmail.GetUserByEmailMock.mutex.Unlock()

	for _, e := range mmGetUserByEmail.GetUserByEmailMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByEmail.GetUserByEmailMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.params
		mm_want_ptrs := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryIMockGetUserByEmailParams{ctx, email}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUserByEmail.t.Errorf("UserRepositoryIMock.GetUserByEmail got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmGetUserByEmail.t.Errorf("UserRepositoryIMock.GetUserByEmail got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByEmail.t.Errorf("UserRepositoryIMock.GetUserByEmail got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByEmail.GetUserByEmailMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByEmail.t.Fatal("No results are set for the UserRepositoryIMock.GetUserByEmail")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByEmail.funcGetUserByEmail != nil {
		return mmGetUserByEmail.funcGetUserByEmail(ctx, email)
	}
	mmGetUserByEmail.t.Fatalf("Unexpected call to UserRepositoryIMock.GetUserByEmail. %v %v", ctx, email)
	return
}

// GetUserByEmailAfterCounter returns a count of finished UserRepositoryIMock.GetUserByEmail invocations
func (mmGetUserByEmail *UserRepositoryIMock) GetUserByEmailAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByEmail.afterGetUserByEmailCounter)
}

// GetUserByEmailBeforeCounter returns a count of UserRepositoryIMock.GetUserByEmail invocations
func (mmGetUserByEmail *UserRepositoryIMock) GetUserByEmailBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByEmail.beforeGetUserByEmailCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryIMock.GetUserByEmail.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByEmail *mUserRepositoryIMockGetUserByEmail) Calls() []*UserRepositoryIMockGetUserByEmailParams {
	mmGetUserByEmail.mutex.RLock()

	argCopy := make([]*UserRepositoryIMockGetUserByEmailParams, len(mmGetUserByEmail.callArgs))
	copy(argCopy, mmGetUserByEmail.callArgs)

	mmGetUserByEmail.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByEmailDone returns true if the count of the GetUserByEmail invocations corresponds
// the number of defined expectations
func (m *UserRepositoryIMock) MinimockGetUserByEmailDone() bool {
	if m.GetUserByEmailMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserByEmailMock.invocationsDone()
}

// MinimockGetUserByEmailInspect logs each unmet expectation
func (m *UserRepositoryIMock) MinimockGetUserByEmailInspect() {
	for _, e := range m.GetUserByEmailMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryIMock.GetUserByEmail at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserByEmailCounter := mm_atomic.LoadUint64(&m.afterGetUserByEmailCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByEmailMock.defaultExpectation != nil && afterGetUserByEmailCounter < 1 {
		if m.GetUserByEmailMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryIMock.GetUserByEmail at\n%s", m.GetUserByEmailMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryIMock.GetUserByEmail at\n%s with params: %#v", m.GetUserByEmailMock.defaultExpectation.expectationOrigins.origin, *m.GetUserByEmailMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByEmail != nil && afterGetUserByEmailCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryIMock.GetUserByEmail at\n%s", m.funcGetUserByEmailOrigin)
	}

	if !m.GetUserByEmailMock.invocationsDone() && afterGetUserByEmailCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryIMock.GetUserByEmail at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserByEmailMock.expectedInvocations), m.GetUserByEmailMock.expectedInvocationsOrigin, afterGetUserByEmailCounter)
	}
}

type mUserRepositoryIMockUpdateUser struct {
	optional           bool
	mock               *UserRepositoryIMock
	defaultExpectation *UserRepositoryIMockUpdateUserExpectation
	expectations       []*UserRepositoryIMockUpdateUserExpectation

	callArgs []*UserRepositoryIMockUpdateUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// UserRepositoryIMockUpdateUserExpectation specifies expectation struct of the UserRepositoryI.UpdateUser
type UserRepositoryIMockUpdateUserExpectation struct {
	mock               *UserRepositoryIMock
	params             *UserRepositoryIMockUpdateUserParams
	paramPtrs          *UserRepositoryIMockUpdateUserParamPtrs
	expectationOrigins UserRepositoryIMockUpdateUserExpectationOrigins
	results            *UserRepositoryIMockUpdateUserResults
	returnOrigin       string
	Counter            uint64
}

// UserRepositoryIMockUpdateUserParams contains parameters of the UserRepositoryI.UpdateUser
type UserRepositoryIMockUpdateUserParams struct {
	ctx  context.Context
	id   int64
	info *model.UserInfo
}

// UserRepositoryIMockUpdateUserParamPtrs contains pointers to parameters of the UserRepositoryI.UpdateUser
type UserRepositoryIMockUpdateUserParamPtrs struct {
	ctx  *context.Context
	id   *int64
	info **model.UserInfo
}

// UserRepositoryIMockUpdateUserResults contains results of the UserRepositoryI.UpdateUser
type UserRepositoryIMockUpdateUserResults struct {
	err error
}

// UserRepositoryIMockUpdateUserOrigins contains origins of expectations of the UserRepositoryI.UpdateUser
type UserRepositoryIMockUpdateUserExpectationOrigins struct {
	origin     string
	originCtx  string
	originId   string
	originInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateUser *mUserRepositoryIMockUpdateUser) Optional() *mUserRepositoryIMockUpdateUser {
	mmUpdateUser.optional = true
	return mmUpdateUser
}

// Expect sets up expected params for UserRepositoryI.UpdateUser
func (mmUpdateUser *mUserRepositoryIMockUpdateUser) Expect(ctx context.Context, id int64, info *model.UserInfo) *mUserRepositoryIMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryIMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserRepositoryIMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.paramPtrs != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryIMock.UpdateUser mock is already set by ExpectParams functions")
	}

	mmUpdateUser.defaultExpectation.params = &UserRepositoryIMockUpdateUserParams{ctx, id, info}
	mmUpdateUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateUser.expectations {
		if minimock.Equal(e.params, mmUpdateUser.defaultExpectation.params) {
			mmUpdateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateUser.defaultExpectation.params)
		}
	}

	return mmUpdateUser
}

// ExpectCtxParam1 sets up expected param ctx for UserRepositoryI.UpdateUser
func (mmUpdateUser *mUserRepositoryIMockUpdateUser) ExpectCtxParam1(ctx context.Context) *mUserRepositoryIMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryIMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserRepositoryIMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryIMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserRepositoryIMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectIdParam2 sets up expected param id for UserRepositoryI.UpdateUser
func (mmUpdateUser *mUserRepositoryIMockUpdateUser) ExpectIdParam2(id int64) *mUserRepositoryIMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryIMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserRepositoryIMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryIMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserRepositoryIMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.id = &id
	mmUpdateUser.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmUpdateUser
}

// ExpectInfoParam3 sets up expected param info for UserRepositoryI.UpdateUser
func (mmUpdateUser *mUserRepositoryIMockUpdateUser) ExpectInfoParam3(info *model.UserInfo) *mUserRepositoryIMockUpdateUser {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryIMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserRepositoryIMockUpdateUserExpectation{}
	}

	if mmUpdateUser.defaultExpectation.params != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryIMock.UpdateUser mock is already set by Expect")
	}

	if mmUpdateUser.defaultExpectation.paramPtrs == nil {
		mmUpdateUser.defaultExpectation.paramPtrs = &UserRepositoryIMockUpdateUserParamPtrs{}
	}
	mmUpdateUser.defaultExpectation.paramPtrs.info = &info
	mmUpdateUser.defaultExpectation.expectationOrigins.originInfo = minimock.CallerInfo(1)

	return mmUpdateUser
}

// Inspect accepts an inspector function that has same arguments as the UserRepositoryI.UpdateUser
func (mmUpdateUser *mUserRepositoryIMockUpdateUser) Inspect(f func(ctx context.Context, id int64, info *model.UserInfo)) *mUserRepositoryIMockUpdateUser {
	if mmUpdateUser.mock.inspectFuncUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("Inspect function is already set for UserRepositoryIMock.UpdateUser")
	}

	mmUpdateUser.mock.inspectFuncUpdateUser = f

	return mmUpdateUser
}

// Return sets up results that will be returned by UserRepositoryI.UpdateUser
func (mmUpdateUser *mUserRepositoryIMockUpdateUser) Return(err error) *UserRepositoryIMock {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryIMock.UpdateUser mock is already set by Set")
	}

	if mmUpdateUser.defaultExpectation == nil {
		mmUpdateUser.defaultExpectation = &UserRepositoryIMockUpdateUserExpectation{mock: mmUpdateUser.mock}
	}
	mmUpdateUser.defaultExpectation.results = &UserRepositoryIMockUpdateUserResults{err}
	mmUpdateUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// Set uses given function f to mock the UserRepositoryI.UpdateUser method
func (mmUpdateUser *mUserRepositoryIMockUpdateUser) Set(f func(ctx context.Context, id int64, info *model.UserInfo) (err error)) *UserRepositoryIMock {
	if mmUpdateUser.defaultExpectation != nil {
		mmUpdateUser.mock.t.Fatalf("Default expectation is already set for the UserRepositoryI.UpdateUser method")
	}

	if len(mmUpdateUser.expectations) > 0 {
		mmUpdateUser.mock.t.Fatalf("Some expectations are already set for the UserRepositoryI.UpdateUser method")
	}

	mmUpdateUser.mock.funcUpdateUser = f
	mmUpdateUser.mock.funcUpdateUserOrigin = minimock.CallerInfo(1)
	return mmUpdateUser.mock
}

// When sets expectation for the UserRepositoryI.UpdateUser which will trigger the result defined by the following
// Then helper
func (mmUpdateUser *mUserRepositoryIMockUpdateUser) When(ctx context.Context, id int64, info *model.UserInfo) *UserRepositoryIMockUpdateUserExpectation {
	if mmUpdateUser.mock.funcUpdateUser != nil {
		mmUpdateUser.mock.t.Fatalf("UserRepositoryIMock.UpdateUser mock is already set by Set")
	}

	expectation := &UserRepositoryIMockUpdateUserExpectation{
		mock:               mmUpdateUser.mock,
		params:             &UserRepositoryIMockUpdateUserParams{ctx, id, info},
		expectationOrigins: UserRepositoryIMockUpdateUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateUser.expectations = append(mmUpdateUser.expectations, expectation)
	return expectation
}

// Then sets up UserRepositoryI.UpdateUser return parameters for the expectation previously defined by the When method
func (e *UserRepositoryIMockUpdateUserExpectation) Then(err error) *UserRepositoryIMock {
	e.results = &UserRepositoryIMockUpdateUserResults{err}
	return e.mock
}

// Times sets number of times UserRepositoryI.UpdateUser should be invoked
func (mmUpdateUser *mUserRepositoryIMockUpdateUser) Times(n uint64) *mUserRepositoryIMockUpdateUser {
	if n == 0 {
		mmUpdateUser.mock.t.Fatalf("Times of UserRepositoryIMock.UpdateUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateUser.expectedInvocations, n)
	mmUpdateUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateUser
}

func (mmUpdateUser *mUserRepositoryIMockUpdateUser) invocationsDone() bool {
	if len(mmUpdateUser.expectations) == 0 && mmUpdateUser.defaultExpectation == nil && mmUpdateUser.mock.funcUpdateUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateUser.mock.afterUpdateUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateUser implements mm_repository.UserRepositoryI
func (mmUpdateUser *UserRepositoryIMock) UpdateUser(ctx context.Context, id int64, info *model.UserInfo) (err error) {
	mm_atomic.AddUint64(&mmUpdateUser.beforeUpdateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateUser.afterUpdateUserCounter, 1)

	mmUpdateUser.t.Helper()

	if mmUpdateUser.inspectFuncUpdateUser != nil {
		mmUpdateUser.inspectFuncUpdateUser(ctx, id, info)
	}

	mm_params := UserRepositoryIMockUpdateUserParams{ctx, id, info}

	// Record call args
	mmUpdateUser.UpdateUserMock.mutex.Lock()
	mmUpdateUser.UpdateUserMock.callArgs = append(mmUpdateUser.UpdateUserMock.callArgs, &mm_params)
	mmUpdateUser.UpdateUserMock.mutex.Unlock()

	for _, e := range mmUpdateUser.UpdateUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateUser.UpdateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateUser.UpdateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateUser.UpdateUserMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateUser.UpdateUserMock.defaultExpectation.paramPtrs

		mm_got := UserRepositoryIMockUpdateUserParams{ctx, id, info}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateUser.t.Errorf("UserRepositoryIMock.UpdateUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmUpdateUser.t.Errorf("UserRepositoryIMock.UpdateUser got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

			if mm_want_ptrs.info != nil && !minimock.Equal(*mm_want_ptrs.info, mm_got.info) {
				mmUpdateUser.t.Errorf("UserRepositoryIMock.UpdateUser got unexpected parameter info, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.originInfo, *mm_want_ptrs.info, mm_got.info, minimock.Diff(*mm_want_ptrs.info, mm_got.info))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateUser.t.Errorf("UserRepositoryIMock.UpdateUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateUser.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateUser.UpdateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateUser.t.Fatal("No results are set for the UserRepositoryIMock.UpdateUser")
		}
		return (*mm_results).err
	}
	if mmUpdateUser.funcUpdateUser != nil {
		return mmUpdateUser.funcUpdateUser(ctx, id, info)
	}
	mmUpdateUser.t.Fatalf("Unexpected call to UserRepositoryIMock.UpdateUser. %v %v %v", ctx, id, info)
	return
}

// UpdateUserAfterCounter returns a count of finished UserRepositoryIMock.UpdateUser invocations
func (mmUpdateUser *UserRepositoryIMock) UpdateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.afterUpdateUserCounter)
}

// UpdateUserBeforeCounter returns a count of UserRepositoryIMock.UpdateUser invocations
func (mmUpdateUser *UserRepositoryIMock) UpdateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateUser.beforeUpdateUserCounter)
}

// Calls returns a list of arguments used in each call to UserRepositoryIMock.UpdateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateUser *mUserRepositoryIMockUpdateUser) Calls() []*UserRepositoryIMockUpdateUserParams {
	mmUpdateUser.mutex.RLock()

	argCopy := make([]*UserRepositoryIMockUpdateUserParams, len(mmUpdateUser.callArgs))
	copy(argCopy, mmUpdateUser.callArgs)

	mmUpdateUser.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateUserDone returns true if the count of the UpdateUser invocations corresponds
// the number of defined expectations
func (m *UserRepositoryIMock) MinimockUpdateUserDone() bool {
	if m.UpdateUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateUserMock.invocationsDone()
}

// MinimockUpdateUserInspect logs each unmet expectation
func (m *UserRepositoryIMock) MinimockUpdateUserInspect() {
	for _, e := range m.UpdateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to UserRepositoryIMock.UpdateUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateUserCounter := mm_atomic.LoadUint64(&m.afterUpdateUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateUserMock.defaultExpectation != nil && afterUpdateUserCounter < 1 {
		if m.UpdateUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to UserRepositoryIMock.UpdateUser at\n%s", m.UpdateUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to UserRepositoryIMock.UpdateUser at\n%s with params: %#v", m.UpdateUserMock.defaultExpectation.expectationOrigins.origin, *m.UpdateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateUser != nil && afterUpdateUserCounter < 1 {
		m.t.Errorf("Expected call to UserRepositoryIMock.UpdateUser at\n%s", m.funcUpdateUserOrigin)
	}

	if !m.UpdateUserMock.invocationsDone() && afterUpdateUserCounter > 0 {
		m.t.Errorf("Expected %d calls to UserRepositoryIMock.UpdateUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateUserMock.expectedInvocations), m.UpdateUserMock.expectedInvocationsOrigin, afterUpdateUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UserRepositoryIMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateUserInspect()

			m.MinimockDeleteUserInspect()

			m.MinimockGetUserInspect()

			m.MinimockGetUserByEmailInspect()

			m.MinimockUpdateUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UserRepositoryIMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UserRepositoryIMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteUserDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockGetUserByEmailDone() &&
		m.MinimockUpdateUserDone()
}
